<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>J & V — Invitación de Boda</title>

  <style>
:root{
  --bGold: rgba(201,151,43,.34);
  --bChamp: rgba(241,209,138,.32);
  --bCream: rgba(255,248,235,.34);
  --bWhite: rgba(255,255,255,.26);
}

    *{ box-sizing:border-box; }
    img{ max-width:100%; height:auto; }

    html, body{ width:100%; height:100%; margin:0; }

    body{
      display:grid;
      place-items:center;

      min-height:100vh;
      min-height:100svh;
      min-height:100dvh;

      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#fff;
      overflow:hidden;
      padding:18px;
      text-align:center;
      color:#222;
      position:relative;
    }

    .bg-base{
      position:fixed;
      inset:0;
      z-index:0;
      background: linear-gradient(135deg,
        #ffffff 0%,
        #fff6e6 25%,
        #f1d18a 55%,
        #fffaf1 80%,
        #ffffff 100%);
      background-size:300% 300%;
      animation: baseMove 7s ease-in-out infinite;
      pointer-events:none;
    }

    #bubblesCanvas{
      position:fixed;
      inset:0;
      z-index:1;
      pointer-events:none;

      display:block;
      opacity:0.92;
      mix-blend-mode: normal;

      filter: saturate(1.06) contrast(1.10);
    }

    .shimmer{
      position:fixed;
      inset:-25%;
      z-index:2;
      pointer-events:none;
      background: linear-gradient(115deg,
        rgba(255,255,255,0) 0%,
        rgba(241,209,138,.65) 45%,
        rgba(255,255,255,0) 60%
      );
      filter: blur(10px);
      opacity:.5;
      animation: shimmerMove 7s ease-in-out infinite;
    }

    @keyframes baseMove{
      0%{ background-position:0% 50%; }
      50%{ background-position:100% 50%; }
      100%{ background-position:0% 50%; }
    }
    @keyframes shimmerMove{
      0%{ transform:translateX(-40%) rotate(6deg); }
      50%{ transform:translateX(10%) rotate(6deg); }
      100%{ transform:translateX(45%) rotate(6deg); }
    }

    .cover{
      width: min(720px, 92vw);
      max-height: 86svh;
      max-height: 86dvh;
      height: auto;

      display:block;
      cursor:pointer;
      user-select:none;
      -webkit-user-drag:none;

      filter: drop-shadow(0 18px 35px rgba(0,0,0,.16));
      transition: transform .25s ease, filter .25s ease;
    }

    @media (min-width: 900px){
      .cover{ width: clamp(468px, 34vw, 684px); max-height: 82vh; }
    }
    @media (max-width: 520px){
      .cover{ width: 92vw; max-height: 84svh; max-height: 84dvh; }
    }

    .cover-wrap{
      position: relative;
      display: grid;
      place-items: center;
      z-index:10;
    }

    .hint{
      position: absolute;
      left: 50%;
      bottom: 6%;
      transform: translateX(-50%);
      width: 92%;
      max-width: 520px;

      font-size: 1.15rem;
      letter-spacing: 1.6px;
      color: rgba(80,80,80,.72);
      text-transform: uppercase;

      opacity: 0;
      animation: hintIn .7s ease forwards;
      animation-delay: 1s;

      pointer-events: none;
      user-select: none;
    }

    @keyframes hintIn{
      from{ opacity:0; transform: translateX(-50%) translateY(6px); }
      to  { opacity:1; transform: translateX(-50%) translateY(0); }
    }

    /* ✅ 1) AJUSTE MOVIL: el texto más cerca del sobre */
    @media (max-width: 520px){
      .hint{
        bottom: 14%;              /* antes 7% -> ahora más arriba */
        font-size: .95rem;
        letter-spacing: 1.2px;
      }
    }

    /* ===== Transición de apertura (más lenta y cálida) ===== */

    /* ✅ easing más “suave/cálido” */
    :root{
      --easeWarm: cubic-bezier(.18,.86,.22,1);
    }

    /* El abierto va encima pero invisible */
    .cover-open{
      position:absolute;
      opacity:0;
      transform: translateY(18px) scale(0.985);
      filter: drop-shadow(0 18px 35px rgba(0,0,0,.16)) blur(0px);
      pointer-events:none;

      /* ✅ 2) transición más lenta */
      transition:
        opacity 1.05s var(--easeWarm),
        transform 1.05s var(--easeWarm),
        filter 1.05s var(--easeWarm);
    }

    /* Feedback táctil */
    .cover.is-press{
      transform: scale(0.985);
      filter: drop-shadow(0 12px 26px rgba(0,0,0,.14));
    }

    /* Cuando abrimos: el cerrado se va (lento) */
    .cover.is-fadeout{
      opacity:0;
      transform: translateY(-16px) scale(1.02);
      filter: drop-shadow(0 24px 45px rgba(0,0,0,.10)) blur(10px);

      /* ✅ transición más lenta también */
      transition:
        opacity 1.15s var(--easeWarm),
        transform 1.15s var(--easeWarm),
        filter 1.15s var(--easeWarm);
    }

    /* El abierto entra (lento + suave) */
    .cover-open.is-show{
      opacity:1;
      transform: translateY(0px) scale(1);
      filter: drop-shadow(0 22px 45px rgba(0,0,0,.18)) blur(0px);
    }

    /* ✅ 2) IMPORTANTE: NO desaparece rápido.
       Solo se desvanece si agregamos is-reveal.
       Así que lo controlamos por tiempo en JS. */
    .cover-open.is-reveal{
      opacity:0;
      transform: translateY(-14px) scale(1.02);
      filter: drop-shadow(0 24px 45px rgba(0,0,0,.10)) blur(12px);
      transition:
        opacity 1.05s var(--easeWarm),
        transform 1.05s var(--easeWarm),
        filter 1.05s var(--easeWarm);
    }

    @media (prefers-reduced-motion: reduce){
      .cover, .cover-open{
        transition:none !important;
        animation:none !important;
        filter:none !important;
        transform:none !important;
      }
    }
  </style>
</head>

<body>
  <div class="bg-base"></div>
  <canvas id="bubblesCanvas"></canvas>
  <div class="shimmer"></div>

  <div class="cover-wrap" id="coverWrap">
    <img src="assets/Sobre-Cerrado.png" alt="Sobre cerrado" class="cover" id="coverClosed" />
    <img src="assets/Sobre.png" alt="Sobre abierto" class="cover cover-open" id="coverOpen" />
    <div class="hint" id="hint">Toca el sobre para abrir</div>
  </div>

  <audio id="bg-music" preload="auto">
    <source src="assets/MusicaparaBoda.m4a" type="audio/mp4">
    Tu navegador no soporta audio.
  </audio>

  <script>
    const coverClosed = document.getElementById("coverClosed");
    const coverOpen   = document.getElementById("coverOpen");
    const music = document.getElementById("bg-music");
    const hint  = document.getElementById("hint");

    let opened = false;

    coverClosed.addEventListener("click", async () => {
      if (opened) return;
      opened = true;

      if (hint) hint.style.display = "none";

      // ✅ 2) Timing más cálido (más lento)
      const PRESS_MS = 150;        // feedback
      const START_TRANSITION_MS = 220; // espera para que se sienta el click
      const OPEN_VISIBLE_MS = 2200; // ✅ tiempo visible del sobre abierto (antes 900)

      // 1) feedback táctil
      coverClosed.classList.add("is-press");
      setTimeout(() => coverClosed.classList.remove("is-press"), PRESS_MS);

      // 2) música (intento)
      try {
        if (music.paused) await music.play();
      } catch (e) {
        console.error("No se pudo reproducir. Verifica el archivo en /assets.", e);
      }

      // 3) transición lenta: cerrado fade out, abierto fade in
      setTimeout(() => {
        coverClosed.classList.add("is-fadeout");
        coverOpen.classList.add("is-show");
      }, START_TRANSITION_MS);

      // 4) después de mostrar el abierto un buen tiempo, revelamos fondo
      setTimeout(() => {
        coverOpen.classList.add("is-reveal");
      }, START_TRANSITION_MS + OPEN_VISIBLE_MS);

      // 5) ocultar al final (cuando ya terminó el reveal)
      setTimeout(() => {
        coverClosed.style.display = "none";
        coverOpen.style.display = "none";
      }, START_TRANSITION_MS + OPEN_VISIBLE_MS + 1200);
    });

    const reduceMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

    if (!reduceMotion) {
      const canvas = document.getElementById("bubblesCanvas");
      const ctx = canvas.getContext("2d", { alpha:true });

      function rand(min, max){ return Math.random() * (max - min) + min; }

      function getVP(){
        const vv = window.visualViewport;
        const w = Math.round(vv ? vv.width  : document.documentElement.clientWidth);
        const h = Math.round(vv ? vv.height : document.documentElement.clientHeight);
        return { w, h };
      }

      let vp = getVP();
      let dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));

      const bubbles = [];
      const COUNT = 18;

      const GOLD_PROB = 0.22;
      const GOLD_A_MIN = 0.24;
      const GOLD_A_MAX = 0.46;

      function resizeCanvas(){
        vp = getVP();
        dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));

        canvas.style.width = vp.w + "px";
        canvas.style.height = vp.h + "px";
        canvas.width  = Math.floor(vp.w * dpr);
        canvas.height = Math.floor(vp.h * dpr);

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        for (const b of bubbles){
          b.x = Math.min(b.x, Math.max(0, vp.w - b.size));
          b.y = Math.min(b.y, Math.max(0, vp.h - b.size));
        }
      }

      function makeBubble(){
        const size = rand(60, 200);

        const r = Math.random();
        const kind = (r < GOLD_PROB) ? "gold" : (r < (GOLD_PROB + 0.39)) ? "cream" : "white";

        let alpha;
        if (kind === "gold") alpha = rand(GOLD_A_MIN, GOLD_A_MAX);
        else if (kind === "cream") alpha = rand(0.34, 0.70);
        else alpha = rand(0.26, 0.60);

        const angle = rand(0, Math.PI * 2);
        const speed = rand(10, 26);

        return {
          kind,
          size,
          x: rand(0, Math.max(0, vp.w - size)),
          y: rand(0, Math.max(0, vp.h - size)),
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          ax: 0, ay: 0,
          steerLeft: rand(0.6, 1.4),
          alpha
        };
      }

      resizeCanvas();
      for (let i=0; i<COUNT; i++) bubbles.push(makeBubble());

      function drawBubble(b){
        const x = b.x + b.size * 0.5;
        const y = b.y + b.size * 0.5;
        const r = b.size * 0.5;

        const hx = x - r * 0.24;
        const hy = y - r * 0.24;

        if (b.kind === "gold"){
          ctx.fillStyle = `rgba(241,209,138,${0.22 * b.alpha})`;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();

          const g = ctx.createRadialGradient(hx, hy, r * 0.06, x, y, r);
          g.addColorStop(0.00, `rgba(255,255,255,${0.85 * b.alpha})`);
          g.addColorStop(0.16, `rgba(255,255,255,${0.28 * b.alpha})`);
          g.addColorStop(0.38, `rgba(241,209,138,${0.62 * b.alpha})`);
          g.addColorStop(0.70, `rgba(201,151,43,${0.32 * b.alpha})`);
          g.addColorStop(0.86, `rgba(201,151,43,${0.14 * b.alpha})`);
          g.addColorStop(1.00, `rgba(255,255,255,0)`);

          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = `rgba(255,255,255,${0.22 * b.alpha})`;
          ctx.lineWidth = 1;
          ctx.stroke();
          return;
        }

        const g = ctx.createRadialGradient(hx, hy, r * 0.10, x, y, r);

        if (b.kind === "cream"){
          g.addColorStop(0.00, `rgba(255,255,255,${0.55 * b.alpha})`);
          g.addColorStop(0.60, `rgba(255,248,235,${0.85 * b.alpha})`);
          g.addColorStop(1.00, `rgba(255,255,255,0)`);
        } else {
          g.addColorStop(0.00, `rgba(255,255,255,${0.50 * b.alpha})`);
          g.addColorStop(0.65, `rgba(255,255,255,${0.35 * b.alpha})`);
          g.addColorStop(1.00, `rgba(255,255,255,0)`);
        }

        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = `rgba(255,255,255,${0.18 * b.alpha})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      function onResizeLike(){ resizeCanvas(); }
      window.addEventListener("resize", onResizeLike, { passive:true });
      window.addEventListener("orientationchange", onResizeLike, { passive:true });
      if (window.visualViewport){
        window.visualViewport.addEventListener("resize", onResizeLike, { passive:true });
        window.visualViewport.addEventListener("scroll", onResizeLike, { passive:true });
      }

      let last = performance.now();

      function tick(now){
        const dt = Math.min(0.033, (now - last) / 1000);
        last = now;

        ctx.clearRect(0, 0, vp.w, vp.h);

        for (const b of bubbles){
          b.steerLeft -= dt;
          if (b.steerLeft <= 0){
            b.steerLeft = rand(0.6, 1.4);
            b.ax = rand(-18, 18);
            b.ay = rand(-18, 18);
          }

          b.vx += b.ax * dt;
          b.vy += b.ay * dt;

          const vmax = 32;
          const v = Math.hypot(b.vx, b.vy) || 1;
          if (v > vmax){
            b.vx = (b.vx / v) * vmax;
            b.vy = (b.vy / v) * vmax;
          }

          b.x += b.vx * dt;
          b.y += b.vy * dt;

          const maxX = Math.max(0, vp.w - b.size);
          const maxY = Math.max(0, vp.h - b.size);

          if (b.x <= 0){ b.x = 0; b.vx = Math.abs(b.vx); }
          if (b.x >= maxX){ b.x = maxX; b.vx = -Math.abs(b.vx); }
          if (b.y <= 0){ b.y = 0; b.vy = Math.abs(b.vy); }
          if (b.y >= maxY){ b.y = maxY; b.vy = -Math.abs(b.vy); }

          drawBubble(b);
        }

        requestAnimationFrame(tick);
      }

      requestAnimationFrame(tick);
    }
  </script>
</body>
</html>
